       
                 CSS: Каскадные таблицы стилей

                  Наследование стилей

При использовании стилей в CSS часто затрагивается не только тот элемент, для которого указаны стили, но и вложенные в него теги. Такие стили называются наследуемые.

Помимо стилей, которые наследуются для всех вложенных тегов, в CSS есть множество стилей, которые уникальны для того элемента, к которому их применили.

Одним из таких свойств является border, позволяющий установить рамку вокруг элемента. Но эта же рамка не будет копироваться для каждого внутреннего элемента.

---------------------------------------------------------
                  Запись стилей в теге style

Возникает естественное желание иметь все стили в одном месте, где можно было бы их быстро редактировать. Таким решением является использование тега <style>, внутри которого могут располагаться все необходимые стили.

Всё, что было записано до открывающей скобки { называется селектор. Селекторы — правила, по которым браузер определяет к какому элементу нужно добавить стили. 

---------------------------------------------------------------------------------------------------------------------

                                        Базовые стили тегов

заголовок первого уровня <h1> в браузерах имеет размер 2em, что обозначает в два раза больше размера шрифта в блоке. Это значение не фиксировано — оно может меняться из-за настроек системы, или если разработчики браузера решили сделать его немного другим.
----------------------------------------------------------------------------------------------

                                          CSS: Классы

Основное решение для стилизации конкретного участка страницы — использование классов. Они помогают задать нужный нам стиль не разом для всех элементов на странице, а только для тех элементов, у которых указан необходимый класс.

Чтобы задать стиль для класса в CSS используется селектор .название-класса. Обратите внимание на точку — именно так браузер понимает, что данный стиль указывается для класса.

-------------------------------------------------------------------------------------------------------

                                          CSS: Селекторы

 Селектор — это описание того, к чему нужно применить тот или иной стиль CSS. Они бывают достаточно сложными, указывая не просто конкретный элемент, но и место, где он находится или внутри какого тега. Вспомним про селектор по классу. Он применяется к любому элементу, класс которого мы указали.
Используйте селектор по тегу только для установки глобальных правил в рамках всего проекта. Это важно, так как стили будут применяться для всех тегов разом и можно, случайно, перезаписать уже существующие стили

Ещё одним способом указать стили является использование селектора по идентификатору. Используя атрибут id, можно указать уникальное имя для любого элемента на странице. Если данное имя указано, то к элементу возможно обратиться используя селектор по идентификатору. Для этого используется селектор вида #имя_идентификатора
Важно помнить, что значение идентификатора уникально. На странице может быть только один элемент с одним конкретным значением. Например, в примере выше уже использован идентификатор red на параграфе. Второго такого элемента на странице не может быть. По этой причине идентификаторы указывают для больших обёрток, например для основной шапки сайта, но это не обязательное условие

-----------------------------------------------------------------------------------------------------------------------
                                      CSS: Приоритет стилей

  Говоря о каскадности, возникает вопрос: «А что произойдёт, если в разных источниках будут одинаковые правила для элемента, но с разными значениями?». В таком случае есть правила, определяющие приоритеты стилей из разных источников. По степени важности список выглядит следующим образом:

Стили в атрибуте тега
Стили в отдельном файле
Стили по умолчанию, которые добавляет браузер
Значения, указанные в атрибуте style будут важнее свойств в теге <style>, а они будут важнее стандартных стилей браузера. 

Приоритеты селекторов
Важной чертой CSS является то, что разные типы селекторов имеют разный приоритет. Если стили противоречат друг другу в разных селекторах, то вступает в дело принцип приоритета.
У селекторов также существуют приоритеты. Условно можно расставить селекторы в следующем порядке по приоритету:

Селектор по идентификатору (#blue)
Селектор по классу (.red)
Селектор по тегу (p)
Где 1 — самый высокий приоритет, а 3 — самый низкий.

По этим правилам можно понять, что свойства указанные в селекторе по идентификатору будет обладать большим приоритетом, чем стили у селектора по тегу и классу. Поэтому параграф в прошлом примере был синим.

Это легко запомнить, если селекторы небольшие, но они могут быть сложнее. В качестве селектора может быть комбинация классов, тегов и так далее. 
Для определения приоритета можно использовать следующие правила, где каждому селектору задаётся его «вес»:

Селектор по тегу: 1
Селектор по классу: 10
Селектор по ID: 100
Стиль в атрибуте тега: 1000
Чтобы узнать, какой селектор будет иметь больший вес, нужно сложить все полученные значения. Например:

Селектор .paragraph состоит из одного класса, а значит его вес — 10
Селектор .paragraph.color-primary состоит из двух классов. Его вес — 20
Таким образом свойства у селектора .paragraph.color-primary будут иметь больший приоритет, чем внутри селектора .paragraph.

Вышеприведённый список для вычисления «весов» или, как ещё говорят, «специфичности свойств» не является абсолютно полным, но этого способа достаточно на первых этапах изучения CSS. С практикой вы научитесь самостоятельно определять приоритет селекторов.

-------------------------------------------------------------------------------
                           
                                       Выравнивание текста

CSS позволяет выровнять текст, используя свойство text-align с 4 основными значениями:

left — по левому краю. Используется по умолчанию
center — по центру
right — по правому краю
justify — по ширине

-----------------------------------------------------------------------------------------------------
                         
                                    Размер шрифта
Управлять размером текста в CSS можно с помощью свойства font-size, 

--------------------------------------------------------------

                                   Насыщенность шрифта

два самых распространённых значения свойства font-weight:

bold — насыщенный шрифт. Внешне текст будет выглядеть так же, как и при использовании тега <strong> или <b>
normal — значение по умолчанию. Полезное значение, если весь текст имеет нестандартную насыщенность, но какой-то участок необходимо сделать стандартным по насыщенности

------------------------------------------------------------------------------------

                                    CSS: Курсив

Для изменения начертания шрифта используется свойство font-style, которое может принимать одно из значений:

normal — обычный вывод текста.
italic — курсивное начертание
oblique — косое начертание

------------------------------------------------------------------------------------------------------

                              
                                     CSS: Капитель

— ею принято обозначать аббревиатуры, а также её используют в первых строчках произведения, чтобы читателю было проще «войти» в текст после заголовка.

Для установки капители используется свойство font-variant с одним из двух основных значений:

normal — нормальное написание текста
small-caps — капитель

---------------------------------------------------------------------------------------------------
           
                                     Горизонтальная черта

Для такого оформления используется свойство text-decoration с тремя основными свойствами:

underline — Подчёркивание текста
line-through — Перечёркивание текста
overline — Надчёркивание текста

-------------------------------------------------------------------------------------------------------------------

                                      Межстрочный интервал

Для установки межстрочного расстояния используется правило line-height. 

----------------------------------------------------------------------------------------------------------------------

                                      Семейство шрифта

Наиболее распространёнными шрифтами являются:

Times New Roman
Arial
Tahoma
Verdana
Courier New
С большей долей вероятности эти шрифты будут установлены и в системе у другого пользователя. Если шрифтов, указанных в свойстве font-family, на компьютере нет, то будет использован шрифт по умолчанию, заданный в настройках браузера.

При подключении стилей хорошей практикой является добавление универсального семейства шрифта в правило font-family. Таких семейств на данный момент 5:

serif — шрифты с засечками (антиквы). Ярким представителем таких шрифтов является Times New Roman
sans-serif — шрифты без засечек (гротеск). Наиболее знакомыми такими шрифтами являются Arial и Verdana
cursive — курсивные шрифты
fantasy — декоративные шрифты. Это семейство используется реже всего. Дело в том, что декоративные шрифты слишком разные, чтобы они были взаимозаменяемые
monospace — моноширинные шрифты. К ним относятся шрифты, в которых все символы имеют одинаковую ширину. Очень часто их используют программисты в текстовых редакторах

---------------------------------------------------------------------------------------------------------------------------

                                  CSS: Обобщённое правило для шрифтов

           
Удобным способом задать свойства для шрифта является использование правила font, которое позволяет указать:

font-style
font-variant
font-weight
font-size / line-height (эти два правила записываются через слэш)
font-family
Шесть разных правил внутри одного! Это помогает сократить CSS код и улучшить его читабельность. Обязательными из них являются font-size и font-family. Остальные можно не указывать.

Пример записи со всеми возможными правилами: font: italic small-caps bold 24px/1.2 Arial;

Запоминание правильного порядка значений. Используя обобщённые свойства вам всегда стоит держать в голове верный порядок значений свойств. В этом легко можно ошибиться на первых этапах изучения. Хорошим вариантом будет использование отдельных свойств, но в том порядке, в котором они идут в обобщённом свойстве. С опытом вы сможете переключиться на одно правило
Обобщённые свойства перебивают отдельные. Если в коде вы указали font-variant: small-caps;, а потом для этого же элемента применили font: 16px/24px sans-serif;, то капитель будет сброшена в значение по умолчанию

-------------------------------------------------------------------------------------------------------------------------

 
                                    CSS: Базовые правила типографики

Используйте стандартные шрифты
Используйте не больше двух шрифтов на странице
Используйте достаточный размер шрифта
Это понятие двойственное, но не следует использовать основной текст со шрифтом меньше 14 пикселей. Если размер шрифта будет меньше, то чтение с мобильных устройств будет пыткой.
Используйте достаточный межстрочный интервал
Самым распространённым межстрочным интервалом является значение в 150% от размера шрифта. Если текст размером 14 пикселей, то межстрочный интервал желательно установить не менее 21 пикселя.
Выравнивайте текст по левому краю

------------------------------------------------------------------------------------------------------------------------------

                                         CSS: Рамки
                                

border-width — ширина границы
border-style — стиль границы
border-color — цвет границы

и есть значение none, которое «удалит» границу, так как при значении border-style: none браузеры игнорируют другие свойства и удаляют границу

-------------------------------------------------------------------------------------------------------------------------------
                                           CSS: Фон

Для установки фонового цвета используется свойство background-color, 

---------------------------------------------------------------------------------------------
                                         
                                           Внутренние отступы
padding-top — внутренний отступ сверху
padding-right — внутренний отступ справа
padding-bottom — внутренний отступ снизу
padding-left — внутренний отступ слева

Помимо такой записи для удобства существуют сокращённые записи этих правил:

Если указать только одно значение, то оно будет использовано одновременно для всех сторон
Если указать два значения, то первое будет использоваться для отступов по вертикали (сверху и снизу), а второе по горизонтали (справа и слева)
Если указать три значения, то они будут использоваться для отступа сверху, по горизонтали и снизу

------------------------------------------------------------------------------------------------------------
                                            CSS: Внешние отступы
                                  

margin-top — внешний отступ сверху
margin-right — внешний отступ справа
margin-bottom — внешний отступ снизу
margin-left — внешний отступ слева
Также, как у внутренних отступов, для удобства существуют сокращённые записи этих правил:

Если указать только одно значение, то оно будет использовано одновременно для всех сторон
Если указать два значения, то первое будет использоваться для отступов по вертикали (сверху и снизу), а второе по горизонтали (справа и слева)
Если указать три значения, то они будут использоваться для отступа сверху, по горизонтали и снизу

------------------------------------------------------------------------------------------------------------------------

                                      CSS: Высота и ширина блока

     Для управления высотой и шириной блочных элементов используются правила width и height, принимающие значения ширины и высоты соответственно (например, в пикселях или других доступных единицах измерения).

Создадим блок высотой 100 пикселей и шириной 100 пикселей. Чтобы визуально отделить его от теории в уроке, установим чёрный цвет фона:

<style>
  .square {
    width: 100px;
    height: 100px;
    background-color: #000;
  }
</style>

<div class="square"></div>

--------------------------------------------------------------------------------------------------------------------------

                                      Блочная модель

 Блочная модель
То есть конечный размер формируется не только свойствами height и width, а множеством других свойств:

padding — внутренние отступы
border — границы
margin — внешние границы

.box {
  width: 100px;
  height: 100px;

  padding: 20px;
  margin: 10px;

  border: 1px solid #fff;
}
100px? 120px? 121px? Как узнать это значение? Нужно сложить все значения, которые формируют блок по горизонтали:

width
padding-left/padding-right
border-left/border-right
margin-left/margin-right
Получается, что итоговая ширина элемента на странице: 100px + 20px + 20px + 1px + 1px + 10px + 10px что равно 162px

Такое поведение называется боксовой моделью. Она описывает взаимосвязь свойств и конечного размера элемента. По этой модели браузеры «рисуют» блок, наслаивая правила друг на друга перед тем, как вывести элемент на страницу.

Данную модель стоит хорошо запомнить, потому что при работе с CSS важно понимать, где и как браузер «нарисует» блок, и как это отразится на его высоте и ширине.
Но согласитесь, что устанавливая свойства width и height ожидаешь именно эти значения. Можно ли изменить поведение боксовой модели? Да! Для этого используется свойство box-sizing, которое принимает следующие значения:

content-box — значение по умолчанию. Работает так, как было описано в уроке
border-box — значения границы и внутренних отступов не увеличивают элемент, а «съедают» место у контента, то есть свойства не будут влиять и высоту и ширину. Если установлено фиксированное значение, то оно таким и останется, но для контента внутри останется меньше места

-------------------------------------------------------------------------------------------------------------------------------

                                            CSS: Префиксы

 раньше свойство box-shadow, которое устанавливает тень для элемента находилось в процессе обсуждения и реализации. Для его использования необходимо было дополнительно указать префиксы — небольшие дополнения к свойству, которые указываются перед названием свойства. 
три упоминания свойства box-shadow:

-webkit-box-shadow — свойство для браузера на WebKit
-moz-box-shadow — свойство для браузеров на основе решений от компании Mozilla
box-shadow — свойство без префиксов
Если браузер не мог обработать свойство box-shadow, то он искал свой префикс -webkit- или -moz-. Если не найдено и это, то правило игнорируется. Сейчас же использование таких префиксов поможет использовать свойство box-shadow в очень старых браузерах Chrome, Safari и Firefox.

--------------------------------------------------------------------------------------------------------------------------------

                                       Единицы измерения

  Существует ещё несколько основных относительных единиц измерения:

em. определяется относительно размера шрифта у родительского элемента, т.е. 1.5em будет на 50% больше базового вычисленного размера шрифта родителя. Очень похоже на использование процентов, только указывается немного по другому
rem. определяется относительно размера шрифта у корневого элемента, т.е. у тега html (значение по-умолчанию 16px)

В противовес абсолютным единицам измерения существуют относительные. По их названию понятно, что размер такого элемента не фиксируется, а высчитывается относительно чего-то. В случае с интернет-страницами этим «чего-то» является размер шрифта. Почему именно шрифт? Представьте, что вы, как пользователь, увеличиваете размер шрифта на сайте для собственного удобства. Если отступы, ширина, высота не будет привязана к размеру текста, то такой текст будет выходить за пределы блока. А текст — основа любой страницы в интернете.

Одной из относительных единиц измерения являются проценты. Они считаются от размера шрифта родительского элемента, то есть элемента, внутри которого находятся. Например,

<section class="news">
  <h2>Новости</h2>
</section>
.news {
  font-size: 20px;
}

.news h2 {
  font-size: 200%;
}
Какого размера будет заголовок второго уровня? Правильный ответ: 40px, так как для секции news установлен размер шрифта в 20px. Относительно этого размера и высчитывалось значение 200%. Здесь неважно, какие теги есть ещё, в каких обёртках лежат эти новости — размер считается от значения font-size элемента news.

Но важно помнить, что font-size — наследуемое свойство. Если оно явно не указано у элемента news в нашем примере, то, для него, будет установлено значение font-size родителя. Расширим пример:

<main>
  <section class="news">
    <h2>Новости</h2>
  </section>
</main>
main {
  font-size: 16px;
}

h2 {
  font-size: 200%;
}
Какой размер у заголовка второго уровня? Правильный ответ: 32px. Если построить логическую цепочку размеров шрифта, то она выглядит так:

У элемента <main> размер шрифта установлен в значение 16px
У элемента с классом news нет отдельного указания размера шрифта, поэтому оно наследуется от <main>, то есть тоже 16px
У заголовка второго уровня размер шрифта 200%. Значение устанавливается относительно размера шрифта родителя, то есть блока с классом .news. Итого получается 16px * 2 = 32px

----------------------------------------------------------------------------------------------------------------------------

                                         CSS: Медиа запросы

Для просмотра интернет-страниц используется множество устройств с различным размером и разрешений экрана: компьютеры, смартфоны, планшеты, ноутбуки и так далее. Такое количество устройств требует от разработчиков умение подстраивать свои страницы под разные вариации разрешений.

Один из способов изменить стили в зависимости от разрешения — использовании специальных CSS правил, которые срабатывают при выполнении заданных условий. Такими условиями могут быть:

Ширина или высота viewport
Горизонтальная или вертикальная ориентация экрана
Тип устройства
и другие.

В этом уроке узнаем о правиле @media и рассмотрим несколько стандартных вариантов применения. Задачей урока не является объяснить все тонкости работы с адаптивностью страниц, поэтому сосредоточимся на ключевых вещах.

Правило media
Все медиа запросы строятся по похожему шаблону и используют конструкцию @media:

@media (условие) {
  /* Правила */
}
Какие правила указываются внутри конструкции @media? Абсолютно любые! Думайте об этом, как о новом CSS файле, со своими селекторами, свойствами. Например, для определённого условия нужно изменить цвет текста элементов с классом .text на чёрный. Тогда конструкция примет такой образ:

@media (условие) {
  .text {
    color: #000000;
  }
}
А какие бывают условия? Представим, что нужно изменить цвет текста, если ширина viewport меньше или равно 700 пикселей. Тогда указывается правило max-width: 700px. Очень похоже на обычное CSS правило, которое определит, что свойства должны отрабатывать, если ширина viewport 700 пикселей или меньше:

@media (max-width: 700px) {
  .text {
    color: #000000;
  }
}
С приходом мобильных телефонов остро возникла необходимость работы с тем, как пользователь держит телефон: вертикально или горизонтально. Когда пользователь держит телефон вертикально, то высота экрана больше, чем его ширина. При горизонтальном использовании наоборот — ширина больше высоты. Это требует правильного выстраивания блоков на странице, чтобы ей было удобно пользоваться из любого положения.

В медиа запросах есть специальное условие orientation, которое может иметь одно из двух значений:

portrait — портретная ориентация устройства. Высота экрана больше, чем его ширина
landscape — альбомная ориентация устройства. Высота экрана меньше, чем его ширина
Пусть для портрентной ориентации текст будет белым, а для альбомной чёрным:

@media (orientation: portrait) {
  .text {
    color: #ffffff;
  }
}

@media (orientation: landscape) {
  .text {
    color: #000000;
  }
}
Медиа запросы могут быть куда сложнее, и учитывать множество разных вариаций. В рамках одного урока это не описать, но вы уже познакомились с тем, как строятся медиа запросы, для чего они существуют и как добавить их в свой CSS файл

---------------------------------------------------------------------------------------------------------------------------

                                     CSS: Анимация

    будет показан базовый принцип анимации в CSS на основе @keyframes. Для примера, сделаем анимацию текста — цвет текста меняется с голубого на красный.

Для того, чтобы задать анимацию, используется правило @keyframes и название анимации:
@keyframes color-change {
  // Внутри будет наша анимация
}
Внутри @keyframes необходимо указать различные временные промежутки, в которых будут происходить изменения. Например, на старте (0% завершённости анимации) будет голубой текст, в середине анимации (50%) — красный, и в конце (100%) — возвращаем голубой цвет.

Теперь необходимо применить созданную нами анимацию к тексту на странице. Для этого используется правило animation с тремя основными значениями:

Название анимации
Длительность анимации. Указывается в секундах (1s, 2s, 3s и так далее)
Бесконечная анимация или нет (если бесконечная, то указывается параметр infinite)

.animation-text {
  animation: color-change 3s infinite;
}

-----------------------------------------------------------------------------------------------------------------------------

                                         CSS: Переменные

Переменная создаётся с помощью конструкции --имя-переменной. Имя переменной вы можете выбрать сами. Для примера создадим переменную --main-color, которая будет содержать базовый цвет страниц. Пускай он будет чёрным:

--main-color: #000000;
               
Для создания глобальной переменной её нужно указать в специальной конструкции :root. Обычно это делается в самом начале CSS файла:

:root {
  --main-color: #000000;
}
Теперь можно использовать переменную в любой части нашего CSS-кода. Это делается с помощью специальной конструкции var(--имя-переменной).

:root {
  --main-color: #000000;
}

.news-block {
  background-color: var(--main-color);
}

.left-sidebar {
  background-color: var(--main-color);
}
Если мы хотим установить другой оттенок чёрного цвета, достаточно изменить только значение переменной --main-color, и все изменения автоматически применятся к блокам с классами .news-block и .left-sidebar

-----------------------------------------------------------------------------------------------------------

                                   CSS: Позиционирование

 CSS предоставляет большие возможности по визуальному отображению элементов. Одной из ключевых особенностей CSS является позиционирование — возможность влиять на место отображения элемента на странице.

С помощью правила position мы можем «выдернуть» блок из вёрстки и расположить так, как удобно. Основные значения у свойства position следующие:

relative       (относительное позиционирование). Позволяет изменить расположение элемента относительно того места, где он был расположен до применения свойства. При этом, то место на странице, которое блок занимал ранее, останется. То есть другие блоки не будут вставать на место, где блок располагался до применения правила position.

absolute       (абсолютное позиционирование). «Вынимает» блок из HTML вёрстки и изменяет его расположение относительно левого верхнего угла страницы (или родительского элемента, если у него есть свойство position в значении fixed, absolute, relative, или sticky). В отличии от relative, место, где располагался absolute блок, будет удалено, и другие блоки смогут занять это место
.
fixed.         Также, как и absolute, данное правило извлечёт блок из HTML вёрстки и расположит его в левом верхнем углу. Отличием от абсолютного позиционирования является то, что блок будет «следовать за страницей» и всегда находится в зоне видимости пользователя. Это удобно для создания меню, которые должны следовать за пользователем.

Для управления расположением используются 4 правила CSS: top, right, left и bottom, значением которых являются координаты (например, в пикселях), где будет расположен блок.              




                                    
